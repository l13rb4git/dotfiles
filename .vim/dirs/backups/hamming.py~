# Implementação do modelo de detecção de erros Hamming
# Criadores: Gabriel Costa Lima e Renan Almeida
import os


def main():
    palavra_inicial = input("Digite a palavra que deseja enviar: ")
    # Recebendo do usuário qual tipo de paridade ele deseja usa.
    paridade_usada = escolher_paridade()
    print("\nParidade {} selecionada.\n".format(paridade_usada))

    palavra_codificada = gerar_codigo(palavra_inicial, paridade_usada)
    palavra_modificada = provocar_erros(palavra_codificada)
    input("Pressione [Enter] para continuar.")

    menu(palavra_modificada)


def menu(palavra):
    limpar_tela()
    texto = "\nO que mais deseja fazer?\n" \
        "\n1 - ENVIAR OUTRA MENSAGEM " \
        "\n2 - RECEBER ULTIMA MESSAGEM ENVIADA" \
        "\n0 - SAIR " \
        "\n>>> "

    opcao = input(texto)

    if opcao == '1':
        main()

    elif opcao == '2':
        receber_mensagem(palavra)

    elif opcao == '0':
        print("\nObrigado por ultilizar nosso programa.")


def limpar_tela():
    os.system('clear')


def gerar_codigo(palavra_inicial, paridade_usada):
    """Gera uma palavra de bits com o código de hamming inserido.
    A palavra_inicial será modificada para que futuramente seja
    possível a verificação de sua intreguidade através do código de
    hamming.

    Args:
        palavra_inicial (str): Palavra de bits que se deseja codificar.
    """
    # Organizando a lista de forma a facilitar o processo
    lista_mensagem = organizar_lista(palavra_inicial)
    # Calculando a quantidade de bits redundantes que serão necessários
    qtd_bits_paridade = calculcular_bits_redundantes(palavra_inicial)
    # Definindo qual o valor que cada bit verificador deve receber
    palavra_codificada = calcular_bits_verificadores(lista_mensagem,
                                                     qtd_bits_paridade,
                                                     paridade_usada)

    print("A sua mensagem foi codificada para:\n{}".format(
                                        ' '.join(map(str, palavra_codificada))))

    return palavra_codificada


def organizar_lista(palavra_inicial):
    """Organiza a palavra de bits e seus bits redundantes em uma lista

    Para facilitar o calculo do valor dos bits redundantes já deixo
    suas posições reservadas, semelhante à forma didática encontrada
    em livros.

    Args:
        palavra_inicial: A palavra de bits que se deseja organizar.

    Return:
        lista_organizada (list): A lista já organizada, com as posiçôes
            dos bits redundantes marcadas.
    """
    # Indica a posição dos bits da palavra_inicial na lista_organizada
    i = 0
    # Potencial a qual o 2 será elevado
    # também indica as posições dos bits redundantes
    j = 0
    # Indica a posição geral dos valores na lista final
    # Começa em um porque a primeira prosição deve ser igual a 2 ^ 0
    k = 1
    lista_organizada = []

    while i < len(palavra_inicial):
        # Se a o valor de k apontar para uma posição
        # destinada aos bits redundantes
        if k == 2 ** j:
            # Adicionar um caracter qualquer
            lista_organizada += '-'
            # Aumentar o valor da potencia para apontar para
            # a posição do proximo bit redundante
            j += 1
        else:
            # Adicionar um dos bits da palavra_inicial
            lista_organizada += palavra_inicial[i]
            # Proximo bit da palavra_inicial
            i += 1
        # Proxima posição da lista_organizada
        k += 1
    return lista_organizada


def calcular_bits_verificadores(lista_mensagem,
                                qtd_bits_paridade,
                                paridade_usada):
    """Calcula e coloca na posição correta os bits verificadores.

    Args:
        lista_mensagem (list): Um lista com as posições dos bits
            verificadores reservadas.
        qtd_bits_paridade (int): Quantidade de bits verificadores
            ultilizados para codificar a mensagem.
        paridade_usada (str): String com a opção de paridade escolhida
            pelo usuário (ímpar ou par).

    Return:
        list: A palavra de bits codificada.
    """
    lista_codificada = lista_mensagem.copy()
    # Uma volta no loop para cada bit de verificação.
    for posicao in range(1, qtd_bits_paridade + 1):
        # A noção de posição dos bits e a de index da lista diferem em
        # valores, pois os bits verificadores são espaçados em potencias
        # de 2.
        # Index do bit de paridade que está sendo calculado.
        index_bit = 2 ** (posicao - 1) - 1
        lista_codificada[index_bit] = valor_bit_verficador(posicao,
                                                           lista_mensagem,
                                                           paridade_usada)
    return lista_codificada


def escolher_paridade(mensagem=None):
    """Oferece ao usuário as opções de paridade.

    Mostra na tela as opções para que o usuário escolha qual paridade
    deseja ultilizar.

    Return:
        str: A opçao escolhida, 'impar' se '1', 'par' para um valor
            qualquer.

    """
    if mensagem is None:
        mensagem = "Escolha qual tipo de paridade deseja ultilizar:" \
            " \n1 - Ímpar \n2 - Par \n>>> "

    return "impar" if input(mensagem) == '1' else "par"


def valor_bit_verficador(posicao, lista_mensagem, paridade_usada):
    """Calcula o valor que o bit verificador da vez deve receber.

    O calculo de quais bits de dados cada verificador deve analisar
    é feito com os valores das posições em binário. O primeiro bit
    verificador checa todos os bit da palavra que sua posição em
    binário tem um 1 no bit menos significativo. O segundo bit checa
    os que contém o número 1 no segundo menos significativo, e assim
    por diante.

    Args:
        posicao (int): A potencia de 2 a qual o bit verificador
            calculado pertence.
        lista_mensagem (list): Palavra de bits que está sendo processada
        paridade_usada (str): Paridade escolhida.

    Return:
        str: O valor que o bit verificador deve carregar. '1' ou '0'.

    """
    # Função ultilizada para converter o valor do index para uma
    # string de binários. x = valor a ser convertido
    # n = quantidade de zeros a esquerda.
    def get_bin(x, n): return format(x, 'b').zfill(n)

    soma_positivos = 0
    # index do bit redundante que está sendo calculado.
    index_bit = 2 ** (posicao - 1)

    # Cada valor apartir do bit redundante até o fim da palavra.
    for j in range(index_bit, len(lista_mensagem)):
        # Se o valor do index em bits conter o caracter '1' no bit
        # apontado pela variável posicao.
        if get_bin(j + 1, posicao)[- posicao] == '1':
            # Soma-se o valor que o index j apontar na lista.
            soma_positivos += int(lista_mensagem[j])

    return resultado_paridade(soma_positivos, paridade_usada)


def resultado_paridade(soma, paridade_usada):
    """Define o valor binário do bit com base na paridade escolhida.

    Analisando se a soma de bits positivos pertence aos números ímpares
    ou pares, com base também na paridade ultilizada, defininos qual
    valor o bit redundante irá receber.

    Args:
        soma (int): Somatório de todos os bits positivos analisados pelo
            verificador.
        paridade_usada: A paridade escolhida pelo usuário.

    Return:
        str: Existem quatro possibilidades:
            Se paridade par e soma par     -> '1'
            Se paridade par e soma ímpar   -> '0'
            Se paridade ímpar e soma ímpar -> '1'
            Se paridade ímpar e soma par   -> '0'
    """
    if paridade_usada == 'par':
        return '1' if soma % 2 == 0 else '0'
    else:
        return '1' if soma % 2 != 0 else '0'


def calculcular_bits_redundantes(palavra_inicial):
    """ Calcula a quantidade de bits de paridade necessários.

    Utiliza-se a formula 2 ^ r >= m + r + 1, onde r = quantidade de
    bits redundantes e m = quantidade de bits de dados.

    Args:
        palavra_inicial: A palavra de bits que o usuário pretende
            enviar.

    Return:
        n_redundant_bits (int): A quantidade de bits redundantes
            necessárias para o funcionamento do hamming code.

    """
    n_data_bits = len(palavra_inicial)
    n_redundant_bits = 0

    while n_data_bits + n_redundant_bits + 1 > 2 ** n_redundant_bits:
        n_redundant_bits += 1

    return n_redundant_bits


def provocar_erros(palavra_codificada):
    """ Modifica o valor de bits de acordo com a escolha do usuário

    Pergunta ao usuário se ele deseja provocar erros na mensagem, caso
    a resposta seja positiva inicia a rotina para a modificação dos bits.

    """
    # Messagem a ser mostrada na tela
    texto = "\nDeseja provocar algum erro na mensagem? [Y/n] "
    # Respostas aceitaveis
    respostas_possiveis = ['y', 'Y', 'n', 'N']
    # Recebendo do usuário a resposta
    opcao = input(texto)
    # palavra_modificada será o return da função
    # então caso o user escolha não provocar erros
    # a mensagem deve ser mantida intacta.
    palavra_modificada = palavra_codificada.copy()

    while opcao not in respostas_possiveis:
        print("Por favor, apenas y - sim ou n - não.")
        opcao = input(texto)

    else:
        # A primeira metade de intens na lista de resposta são positivas
        if opcao in respostas_possiveis[:-2]:
            bits_escolhidos = escolher_bit(palavra_codificada)
            palavra_modificada = modificar_bits(palavra_codificada,
                                                bits_escolhidos)
            mostrar_diferenca(palavra_codificada, palavra_modificada)

    return palavra_modificada


def escolher_bit(palavra_codificada):
    """ Escolhe quais bits serão modificados
    A quantidade de bits e os bits escolhidos fica a critério do user
    porém se ele escolher provocar mais de um erro a integridade da
    mensagem será totalmente violada.

    Return:
        bit_selecionado (list): Um lista com a posição dos bits que o
            user deseja modificar. NÃO é o index.

    """
    def opcao_invalida(opcao, maximo): return opcao > maximo or opcao <= 0
    texto = "\nPalavra tem {} bits.\n".format(len(palavra_codificada))
    texto += "Em quantos bits deseja causar erros? \n>>> "
    qtd_bits = int(input(texto))

    while opcao_invalida(qtd_bits, len(palavra_codificada)):
        print("Quantidade inválida. \n", texto)
        qtd_bits = int(input(texto))

    else:
        msg_erro = "\nATENÇÃO: Você escolheu provocar {} erros, isso " \
            "impossibilitará que o receptor faça a correção deles.".format(
                                                                    qtd_bits)
        if qtd_bits > 1:
            print(msg_erro)

        bits_escolhidos = []

        for i in range(qtd_bits):
            texto = "Digite o número da posição do {}º bit " \
                    "que deseja modificar.\n>>> ".format(i + 1)
            bit_selecionado = int(input(texto))

            while opcao_invalida(qtd_bits, len(palavra_codificada)):
                print("Esse bit não existe na mensagem.")
                bit_selecionado = int(input(texto))

            else:
                bits_escolhidos.append(bit_selecionado)

    return bits_escolhidos


def modificar_bits(palavra_codificada, posicao_bits_escolhidos):
    """ Modifica o valor binario dos bits que constam na lista

    Args:
        palavra_codificada: A palavra de bits que os bits pertencem.
        posicao_bits_escolhidos: Posição do bits a serem modificados,
            NÃO é o index.

    Return:
        list: Palavra com os bits já modificados.

    """
    palavra_modificada = palavra_codificada.copy()
    for i in posicao_bits_escolhidos:
        palavra_modificada[i - 1] = trocar_binario(palavra_modificada[i - 1])

    return palavra_modificada


def trocar_binario(binario):
    """ Troca o valor do bit passado como argumento. """
    return '1' if binario == '0' else '0'


def mostrar_diferenca(palavra_codificada, palavra_modificada):
    """ Formata as palavras de bits para melhor mostra-las na tela.

    Serão printadas na tela duas palavras de bits, para que assim o
    usuário veja como as duas diferem.

    """
    texto = "\nSua mensagem foi modificada de: \n{}\n".format(
                                        ' '.join(map(str, palavra_codificada)))

    texto += "\nPara: \n{}".format(' '.join(map(str, palavra_modificada)))
    print(texto)


def receber_mensagem(palavra_modificada):
    """ Simula o comportamento de um receptor de dados.

    Assim como um receptor esta função recebe, verifica se há erros, e
    caso possível irá corriji-lo. Ao final mostrará ao user a mensagem
    que foi recebida.

    """
    # Caso não seja encontrado erros na palavra ela deve ser mantida
    # da mesma forma que chegou.
    palavra_corrigida = palavra_modificada.copy()
    # Solicitar ao usuário qual paridade foi ultilizada no envio.
    mensagem = '\nQual paridade foi ultilizada? \n1 - Impar \n2 - Par \n>>> '
    paridade_usada = escolher_paridade(mensagem)

    # Encontra o index do bits verificadores usados nesta mensagem
    index_bits_recebidos = bits_redundantes(palavra_modificada)
    # Calcular com base nos bits de dados a palavra
    # que supostamente deveria que chegado.
    palavra_esperada = calcular_bits_verificadores(palavra_modificada,
                                                   len(index_bits_recebidos),
                                                   paridade_usada)

    index_bit_errado = encontrar_erro(palavra_modificada,
                                      palavra_esperada,
                                      index_bits_recebidos)

    if index_bit_errado > 0:
        palavra_corrigida = modificar_bits(palavra_modificada,
                                           [index_bit_errado])

        print("\nEncontrado erro no bit {}. \n".format(index_bit_errado))

    else:
        print("\nNenhum erro encontrado.")

    print("Sua mensagem: \n{}".format(mensagem_formatada(palavra_corrigida,
                                                         index_bits_recebidos)))


def bits_redundantes(palavra_modificada):
    """ Encontra o index dos bits verificadores da palavra.

    Return:
        list: Os index de todos os bits redundantes.
    """
    index_bits_redundantes = []
    j = 0
    i = 0

    while i < len(palavra_modificada):
        if i + 1 == 2 ** j:
            index_bits_redundantes.append(i)
            j += 1

        i += 1

    return index_bits_redundantes


def encontrar_erro(palavra_recebida, palavra_esperada, index_bits_redundantes):
    """ Encontra o erro apartir da comparação entre os bits verificadores """
    index_bit_errado = 0

    for index in index_bits_redundantes:
        # Se o valor esperado para o bit verificador for diferente.
        if palavra_recebida[index] != palavra_esperada[index]:
            # È somado o index até achar a posição onde está o erro.
            index_bit_errado += index + 1

    return index_bit_errado


def mensagem_formatada(palavra_recebida, index_bits_recebidos):
    """ Formata a mensagem recebida para mostra-la na tela corretamente

    Retira-se os bits verificadores e organiza os bits de dados em uma
    string espaçando os bits.

    """
    count = 0
    for index in index_bits_recebidos:
        palavra_recebida.pop(index - count)
        count += 1

    return " ".join(map(str, palavra_recebida))


if __name__ == "__main__":
    main()
