import os


class Hamming(object):
    def __init__(self, palavra, paridade_escolhida):
        self.palavra_inicial = palavra
        self.paridade_usada = paridade_escolhida
        self.organizar_lista()
        self.calcular_bits_verificadores()
        self.palavra_modificada = self.lista_codificada.copy()

    def organizar_lista(self):
        """Organiza os bits da palavra e seus bits redundantes em uma lista

        Para facilitar o calculo do valor dos bits redundantes já deixo
        suas posições reservadas, semelhante à forma didática encontrada
        em livros.

        """
        # Indica a posição dos bits da palavra_inicial na lista_organizada
        index_bits_dados = 0
        # Potência a qual o 2 será elevado
        # também indica as posições dos bits redundantes
        count_power = 0
        # Indica a posição geral dos valores na lista final
        # Começa em um porque a primeira prosição deve ser igual a 2 ^ 0
        index_geral = 1
        lista_organizada = []
        index_bits_redundantes = []

        while index_bits_dados < len(self.palavra_inicial):
            # Se a o valor de index_geral apontar para uma posição
            # destinada aos bits redundantes
            if index_geral == 2 ** count_power:
                # Adicionar um caracter qualquer
                lista_organizada.append('-')
                # Aumentar o valor da potencia para apontar para
                # a posição do proximo bit redundante
                count_power += 1
                # Armazena a posição na lista de index de bits verificadores
                index_bits_redundantes.append(index_geral - 1)
            else:
                # Adicionar um dos bits da palavra_inicial
                lista_organizada.append(self.palavra_inicial[index_bits_dados])
                # Proximo bit da palavra_inicial
                index_bits_dados += 1
            # Proxima posição da lista_organizada
            index_geral += 1

        self.lista_organizada = lista_organizada
        self.index_redundantes = index_bits_redundantes

    def calcular_bits_verificadores(self):
        """Calcula e coloca na posição correta os bits verificadores. """

        lista_codificada = self.lista_organizada.copy()
        # Uma volta no loop para cada bit de verificação.
        for index in self.index_redundantes:
            lista_codificada[index] = self.valor_bit_verficador(index)

        self.lista_codificada = lista_codificada

    def valor_bit_verficador(self, index_verificador):
        """Calcula o valor que o bit verificador da vez deve receber.

        O calculo de quais bits de dados cada verificador deve analisar
        é feito com os valores das posições em binário. O primeiro bit
        verificador checa todos os bit da palavra que sua posição em
        binário tem um 1 no bit menos significativo. O segundo bit checa
        os que contém o número 1 no segundo menos significativo, e assim
        por diante.

        Args:
            index_verificador (int): Index do bit verificador cujo o valor
                que está sendo calculado.

        Return:
            str: O valor que o bit verificador deve carregar. '1' ou '0'.

        """
        soma_positivos = 0

        # Verificar cada valor apartir do bit redundante até o fim da palavra.
        for i in range(index_verificador + 1, len(self.lista_organizada)):
            # Se o valor do index em bits conter o caracter '1' no bit
            # apontado pela variável posicao.
            if self.pertence_paridade(i, index_verificador):
                # Soma-se o valor que o index j apontar na lista.
                soma_positivos += int(self.lista_organizada[i])

        return self.resultado_paridade(soma_positivos)

    def pertence_paridade(self, index, index_verificador):
        """Verifica se o bit pertence à paridade do verificador.

        Args:
            index (int): Index do bit a ser verificado.
            index_verificador (int): Index do bit redundante que o valor
                está sendo calculado.

        Return:
            bool: True se o valor binario do index tem um bit positivo
                na posicao nº dos bits redundantes.

        """
        # Função ultilizada para converter o valor do index para uma
        # string de binários. x = valor a ser convertido
        # n = quantidade de zeros a esquerda.
        def get_bin(x, n): return format(x, 'b').zfill(n)

        # Conseguindo a nº posicao
        posicao = self.index_redundantes.index(index_verificador) + 1

        # Covertendo o index em binário.
        bin_posicao = get_bin(index + 1, posicao)

        # Verificando o nº bit do index em binário.
        return bin_posicao[- posicao] == '1'

    def resultado_paridade(self, soma):
        """Define o valor binário do bit com base na paridade escolhida.

        Analisando se a soma de bits positivos pertence aos números ímpares
        ou pares, com base também na paridade ultilizada, defininos qual
        valor o bit redundante irá receber.

        Args:
            soma (int): Somatório de todos os bits positivos analisados pelo
                verificador.

        Return:
            str: Existem quatro possibilidades:
                Se paridade par e soma par     -> '1'
                Se paridade par e soma ímpar   -> '0'
                Se paridade ímpar e soma ímpar -> '1'
                Se paridade ímpar e soma par   -> '0'

        """
        if self.paridade_usada == 'par':
            return '1' if soma % 2 == 0 else '0'
        else:
            return '1' if soma % 2 != 0 else '0'

    def modificar_bits(self, posicao_bits_escolhidos):
        """ Modifica o valor binario dos bits que constam na lista

        Args:
            index_bits (list): Index dos bits a serem modificados.

        """
        palavra_modificada = self.palavra_modificada
        for i in posicao_bits_escolhidos:
            palavra_modificada[i] = self.trocar_binario(palavra_modificada[i])

        self.palavra_modificada = palavra_modificada

    def trocar_binario(self, binario):
        """ Troca o valor do bit passado como argumento. """
        return '1' if binario == '0' else '0'


class Receptor(Hamming):
    def __init__(self, palavra_recebida, paridade_usada):
        self.palavra_recebida = palavra_recebida
        self.lista_organizada = palavra_recebida
        self.paridade_usada = paridade_usada
        self.index_redundantes = self.bits_redundantes()
        self.calcular_bits_verificadores()
        self.palavra_esperada = self.lista_codificada
        self.index_bit_errado = self.encontrar_erro()
        self.palavra_corrigida = self.palavra_recebida

    def encontrar_erro(self):
        """Encontra o erro apartir da comparação entre os bits verificadores"""
        index_bit_errado = 0

        for index in self.index_redundantes:
            # Se o valor esperado para o bit verificador for diferente.
            if self.palavra_recebida[index] != self.palavra_esperada[index]:
                # È somado o index até achar a posição onde está o erro.
                index_bit_errado += index + 1

        return index_bit_errado - 1

    def corrigir_erro(self):
        self.palavra_corrigida = self.corrigir_bit(self.index_bit_errado)

    def corrigir_bit(self, index_bit_errado):
        """ Corrige o valor binario do bit errado.

        Args:
            index_bits (list): Index dos bits a serem modificados.

        """
        palavra_recebida = self.palavra_recebida
        palavra_recebida[index_bit_errado] = self.trocar_binario(
                                            palavra_recebida[index_bit_errado])

        return palavra_recebida

    def bits_redundantes(self):
        """ Encontra o index dos bits verificadores da palavra.

        Return:
            list: Os index de todos os bits redundantes.
        """
        index_bits_redundantes = []
        j = 0
        i = 0

        while i < len(self.lista_organizada):
            if i + 1 == 2 ** j:
                index_bits_redundantes.append(i)
                j += 1

            i += 1

        return index_bits_redundantes


class Interface():
    def __init__(self):
        self.banner = self.get_banner()
        under_line = '=' * 60
        self.head = self.banner + under_line

    def get_banner(self):
        """Carrega de um .txt uma ASCII Art com strings formando um HAMMING."""

        lista_banner = []
        banner = ''

        with open('banner.txt', 'r', encoding = 'utf-8') as arq_banner:
            for line in arq_banner:
                lista_banner.append(line)

        for row in lista_banner:
            banner += row

        return banner

    def solicitar_palavra(self):
        """Mensagem solicitando ao usuário a palavra de bits a ser enviada."""

        self.body = "\nDigite a palavra de bits que deseja enviar\n" \
                    "Caso queira sair, deixe em branco:\n>> "

    def solicitar_erros(self):
        """Mensagem questionando a chance de provocar erros na mensagem. """

        self.body = "\nDeseja provocar algum erro na mensagem? [Y/n] "

    def solicitar_qtd_bits(self, qtd_bits):
        """Solicita uma quantidade dentro do intervalo de 0 a qtd_bits. """

        texto = "\nA palavra tem {} bits.\n".format(qtd_bits)
        texto += "Em quantos bits deseja causar erros? \n>> "
        self.body = texto

    def solicitar_bits(self, n_bit):
        """Solicita a posição do enésimo bit a ser modificado. """

        texto = "Digite o número da posição do {}º bit " \
                "que deseja modificar.\n>>> ".format(n_bit + 1)
        self.body = texto

    def opcoes_paridade(self):
        """Oferece ao usuário as opções de paridade.

        Mostra na tela as opções para que o usuário escolha qual paridade
        deseja ultilizar.

        """
        mensagem = "Escolha qual tipo de paridade deseja utilizar:" \
            " \n1 - Ímpar \n2 - Par \n>> "

        self.body = mensagem

    def palavra_formatada(self, palavra, index_redundantes):
        """ Formata a mensagem recebida para mostra-la na tela corretamente

        Retira-se os bits verificadores e organiza os bits de dados em uma
        string espaçando os bits.

        """
        count = 0
        for index in index_redundantes:
            palavra.pop(index - count)
            count += 1

        return " ".join(map(str, palavra))

    def mostrar_mensagem(self, palavra, index_bits_recebidos):
        """Organiza a palavra de bits para a facilitar a sua leitura. """

        texto = "\nSua mensagem: \n{}".format(
            self.palavra_formatada(palavra, index_bits_recebidos))
        texto += "\n\nPressione [Enter] para continuar."

        self.body += texto

    def mostrar_diferenca(self, palavra_antiga, palavra_nova):
        """Mostra na tela as mudanças feitas na palavra. """

        texto = "\nSua mensagem foi modificada de:\n{}\n".format(
                                            ' '.join(map(str, palavra_antiga)))

        texto += "\nPara:\n{}\n".format(' '.join(map(str, palavra_nova)))
        texto += "\nPressione [Enter] para continuar."
        self.body = texto

    def menu(self):
        """Menu com as funcinalidade disponíveis. """

        texto = "\nO que mais deseja fazer?\n" \
            "\n1 - Enviar Outra Mensagem\n " \
            "\n2 - Provocar Erros Na Última Mensagem\n" \
            "\n3 - Receber Ultima Messagem Enviada\n" \
            "\n0 - Sair " \
            "\n>>> "

        self.body = texto

    def mostrar_erro(self, erro):
        """Dicionario com um conjuto de erros que podem ocorrer. """

        erros = {
            'resposta_incorreta': "\nPor favor, apenas y - sim ou n - não. >>",

            'opcao_invalida': "\nOpção inválida. >> ",

            'qtd_invalida': "\nQuantidade Inválida. >> ",

            'inrreversivel': "\n\nATENÇÃO: Você escolheu provocar mais de um "
            "erro,\nisso impossibilitará que o receptor"
            " faça a correção deles."
            "\n\nPressione [Enter] para continuar.",

            'bit_inexistente': "\nEsse bit não existe na mensagem\n>> "}

        self.body += erros[erro]

    def erro_encontrado(self, index_erro):
        """Mensagem informando em qual bit foi encontrado o erro. """

        texto = "\nEncontrado erro no bit {}. \n".format(index_erro + 1)
        self.body = texto

    def sem_erro(self):
        """Mensagem informando a inexistencia de erros na palavra recebida. """

        self.body = "\nNenhum erro encontrado."

    def limpar_tela(self):
        """Ferramenta para retirar todos o caracteres mostrados na tela.

        A função utiliza a biblioteca os para conseguir executar o comando
        clear no prompt. Funcional em sistemas Unix e em Windows. """
        os.system('cls' if os.name == 'nt' else 'clear')

    def encerrar(self):
        """Messagem de encerramento do programa."""

        self.body = "\nObrigado por usar nosso programa.\n"

    def __str__(self):
        """Saída de dados; Junção do banner com o que foi colocado no body. """

        # Limpando o buffer da tela sempre que a atualização dela for precisa
        self.limpar_tela()
        return "{self.head} \n{self.body}".format(self=self)


def main():
    interface = Interface()

    palavra = get_mensagem(interface)
    paridade_escolhida = escolher_paridade(interface)
    hamming = Hamming(palavra, paridade_escolhida)

    comparar_palavras(interface,
                      hamming.palavra_inicial,
                      hamming.lista_codificada)

    menu(hamming, interface)


def menu(hamming, interface):
    while True:
        interface.menu()
        opcao = int(input(interface))

        # Se ultrapassar o limite de opções.
        if opcao > 3 or opcao < 0:
            interface.mostrar_erro('opcao_invalida')
            continue

        # 1 - Enviar Outra Mensagem
        if opcao == 1:
            palavra = get_mensagem(interface)
            paridade_escolhida = escolher_paridade(interface)

            hamming = Hamming(palavra, paridade_escolhida)
            comparar_palavras(interface,
                              hamming.palavra_inicial,
                              hamming.lista_codificada)

        # 2 - Provocar Erros Na Última Mensagem
        elif opcao == 2:
            provocar_erros(hamming, interface)

        # 3 - Receber Ultima Messagem Enviada
        elif opcao == 3:
            palavra_enviada = hamming.palavra_modificada
            receber_mensagem(interface, palavra_enviada)

        # 0 - Sair
        elif opcao == 0:
            encerrar_programa(interface)


def get_mensagem(interface):
    interface.solicitar_palavra()
    palavra = input(interface)

    if not palavra:
        encerrar_programa(interface)

    return palavra


def encerrar_programa(interface):
        interface.encerrar()
        print(interface)
        raise SystemExit


def escolher_paridade(interface):
    """Recebe do usuário a paridade que ele deseja ultilizar.

    A opçao escolhida, 'impar' se '1', 'par' para um valor qualquer.

    """
    interface.opcoes_paridade()
    paridade_escolhida = input(interface)
    return "ímpar" if paridade_escolhida == '1' else "par"


def comparar_palavras(interface, palavra_antiga, palavra_nova):
    interface.mostrar_diferenca(palavra_antiga, palavra_nova)
    # Aguardar a resposta do user
    input(interface)


def provocar_erros(hamming, interface):
    bits_escolhidos = escolher_bits(hamming, interface)

    hamming.modificar_bits(bits_escolhidos)

    comparar_palavras(interface,
                      hamming.lista_codificada,
                      hamming.palavra_modificada)


def escolher_bits(hamming, interface):
    """ Escolhe quais bits serão modificados

    A quantidade de bits e os bits escolhidos fica a critério do user
    porém se ele escolher provocar mais de um erro a integridade da
    mensagem será totalmente violada.

    Return:
        bit_selecionado (list): Um lista com index dos bits que o
            usuário deseja modificar.

    """
    def opcao_invalida(opcao, maximo): return opcao > maximo or opcao <= 0

    max_qtd_bits = len(hamming.lista_codificada)
    interface.solicitar_qtd_bits(max_qtd_bits)
    qtd_bits = int(input(interface))

    while opcao_invalida(qtd_bits, max_qtd_bits):
        interface.mostrar_erro('qtd_invalida')
        qtd_bits = int(input(interface))

    else:
        if qtd_bits > 1:
            interface.mostrar_erro('inrreversivel')
            input(interface)

        bits_escolhidos = []
        for i in range(qtd_bits):
            interface.solicitar_bits(i)
            bit_selecionado = int(input(interface))

            while opcao_invalida(bit_selecionado, max_qtd_bits):
                interface.mostrar_erro('bit_inexistente')
                bit_selecionado = int(input(interface))

            else:
                bits_escolhidos.append(bit_selecionado - 1)

    return bits_escolhidos


def receber_mensagem(interface, palavra_recebida):
    paridade_usada = escolher_paridade(interface)
    receptor = Receptor(palavra_recebida, paridade_usada)

    if receptor.index_bit_errado > 0:
        receptor.corrigir_erro()
        interface.erro_encontrado(receptor.index_bit_errado)

    else:
        interface.sem_erro()

    interface.mostrar_mensagem(receptor.palavra_corrigida,
                               receptor.index_redundantes)
    # Aguardar a resposta do usuário
    input(interface)


if __name__ == '__main__':
    main()
    # try:
    # except:
    #     print("Algo de errado aconteceu. Por favor reinicie o programa.")
